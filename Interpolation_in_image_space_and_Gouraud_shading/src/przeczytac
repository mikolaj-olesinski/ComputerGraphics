# Cieniowanie Gourauda - Dokumentacja

Ten projekt implementuje cieniowanie Gourauda dla trójkątów 2D w języku Java. Cieniowanie Gourauda to technika interpolacji kolorów, która umożliwia płynne przejścia między kolorami przypisanymi do wierzchołków trójkąta.

## Zawartość projektu

Projekt składa się z następujących plików:

1. **Triangle2D.java** - główna klasa implementująca funkcjonalność trójkąta 2D i cieniowanie Gourauda
2. **TriangleTest.java** - aplikacja testowa z interfejsem graficznym pokazująca różne przypadki trójkątów
3. **TrianglePerformanceTest.java** - benchmark porównujący wydajność podstawowej i zoptymalizowanej implementacji
4. **TriangleSpecialCasesTest.java** - testy szczególnych przypadków (zdegenerowane trójkąty, przypadki brzegowe)

## Klasa Triangle2D

Klasa `Triangle2D` reprezentuje trójkąt w przestrzeni 2D i implementuje algorytm cieniowania Gourauda w różnych wersjach:

### Pola klasy
- Współrzędne wierzchołków (x1, y1, x2, y2, x3, y3)
- Kolory wierzchołków (color1, color2, color3)

### Główne metody
- **drawGouraudToImage** - podstawowa implementacja cieniowania Gourauda dla BufferedImage
- **drawGouraudToScreen** - podstawowa implementacja cieniowania Gourauda dla Graphics
- **drawGouraudToImageOptimized** - zoptymalizowana implementacja używająca algorytmu skanowania linii (scanline)
- **drawGouraudToScreenOptimized** - zoptymalizowana implementacja dla Graphics

### Metody pomocnicze
- **interpolateColor** - oblicza kolor w punkcie wewnątrz trójkąta
- **isPointInTriangle** - sprawdza czy punkt znajduje się wewnątrz trójkąta
- **getBoundingBox** - wyznacza prostokąt otaczający trójkąt

## Optymalizacje

Zaimplementowano następujące optymalizacje:

1. **Algorytm skanowania linii (scanline)** - zamiast sprawdzania każdego piksela w bounding box, algorytm wykorzystuje własności spójności linii skanowania
2. **Inkrementalne obliczanie kolorów** - unikanie wielokrotnego obliczania współrzędnych barycentrycznych
3. **Sortowanie wierzchołków** - sortowanie wierzchołków według współrzędnej y pozwala na łatwiejsze rysowanie trójkąta
4. **Obcinanie do granic obrazu** - zapobiega próbom rysowania poza obrazem

## Aplikacje testowe

### TriangleTest

Graficzna aplikacja testowa umożliwiająca:
- Przełączanie między różnymi przypadkami trójkątów
- Przełączanie między podstawową a zoptymalizowaną metodą cieniowania
- Wybór między rysowaniem do obrazu a bezpośrednio na ekran
- Pomiar czasu wykonania operacji rysowania

### TrianglePerformanceTest

Benchmarkowa aplikacja konsolowa mierząca wydajność obu implementacji:
- Generuje dużą liczbę losowych trójkątów
- Wykonuje wielokrotne pomiary czasu
- Oblicza średnie czasy i współczynnik przyspieszenia

### TriangleSpecialCasesTest

Aplikacja testująca szczególne przypadki trójkątów:
- Zdegenerowane trójkąty (punkty na jednej linii)
- Trójkąty z powtórzonymi wierzchołkami
- Trójkąty częściowo lub całkowicie poza obrazem
- Przypadki z różnymi charakterystykami kolorów

## Jak uruchomić testy

1. Skompiluj wszystkie pliki Java:
   ```
   javac Triangle2D.java TriangleTest.java TrianglePerformanceTest.java TriangleSpecialCasesTest.java
   ```

2. Uruchom wybraną aplikację testową:
   ```
   java TriangleTest                # Główna aplikacja testowa
   java TrianglePerformanceTest     # Test wydajności
   java TriangleSpecialCasesTest    # Test przypadków specjalnych
   ```

## Analiza wyników

### Wydajność

Zoptymalizowana implementacja powinna być znacznie szybsza od podstawowej, zwłaszcza dla dużych trójkątów. Typowe przyspieszenie to około 2-5x, w zależności od rozmiaru i kształtu trójkątów.

Główne powody przyspieszenia:
- Eliminacja nadmiarowych obliczeń współrzędnych barycentrycznych
- Szybsze znajdowanie pikseli wewnątrz trójkąta
- Inkrementalne obliczanie wartości kolorów

### Poprawność cieniowania

Oba algorytmy powinny dawać identyczne wizualnie rezultaty. Jednakże, ze względu na różnice w implementacji (zwłaszcza w zaokrągleniach liczb zmiennoprzecinkowych), mogą pojawić się minimalne różnice w kolorach pikseli.

### Obsługa przypadków specjalnych

Implementacja jest odporna na różne przypadki specjalne:
- Zdegenerowane trójkąty (linia lub punkt)
- Wierzchołki poza obszarem obrazu
- Ekstremalne wartości kolorów
- Trójkąty o bardzo małej powierzchni

## Znane ograniczenia

1. Brak obsługi przezroczystości (alpha)
2. Przy bardzo dużych trójkątach mogą wystąpić błędy numeryczne
3. Implementacja nie wykorzystuje akceleracji sprzętowej (GPU)

## Możliwe rozszerzenia

1. Dodanie obsługi przezroczystości (alpha)
2. Implementacja innych metod cieniowania (np. Phonga)
3. Wykorzystanie wielowątkowości do przyspieszenia renderingu
4. Optymalizacja pamięciowa dla dużych obrazów